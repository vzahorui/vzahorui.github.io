---
layout: default
title: Unlocking the power of data
---

<style>
.svg-container {
  display: inline-block;
  position: relative;
  width: 100%;
  padding-bottom: 120%; /* aspect ratio */
  vertical-align: middle;
  overflow: hidden;
}
.svg-content-responsive {
  display: inline-block;
  position: absolute;
  top: 10px;
  left: 0; 
  height: 100%; 
  width : 100%;
}
</style>

<div id="chartId">

<script src='https://d3js.org/d3.v5.min.js'></script>
 
<script>
var width = 1800;
var height = 2200;

var graph =
{
    "nodes": [
        {"id": "Loss Functions", "url": "{{ site.baseurl }}{% link _posts/2019-10-14-loss-functions.md %}", "size": 30, "font": 2},
        {"id": "Linear Transformations", "url": "{{ site.baseurl }}{% link _posts/2020-07-08-linear-transformations.md %}", "size": 18, "font": 1.3},
        {"id": "Time Series Modeling", "url":"{{ site.baseurl }}{% link _posts/2019-07-19-time-series-modeling.md %}", "size": 30, "font": 2},
        {"id": "Clustering", "url":"{{ site.baseurl }}{% link _posts/2021-01-03-clustering-overview.md %}", "size": 30, "font": 2},
        {"id": "Linear Regression", "url": "{{ site.baseurl }}{% link _posts/2019-10-25-linear-regression.md %}", "size": 18, "font": 1.3},
        {"id": "Non-Linear Regression", "url": "{{ site.baseurl }}{% link _posts/2020-05-07-non-linear-regression.md %}", "size": 18, "font": 1.3},
        {"id": "LOESS", "url": "{{ site.baseurl }}{% link _posts/2020-05-05-loess.md %}", "size": 4, "font": 1},
        {"id": "Interpolation", "url": "{{ site.baseurl }}{% link _posts/2019-12-08-interpolation.md %}", "size": 4, "font": 1},
        {"id": "Correlation", "url": "{{ site.baseurl }}{% link _posts/2019-08-10-correlation.md %}", "size": 4, "font": 1},
        {"id": "Sampling Distribution", "url": "{{ site.baseurl }}{% link _posts/2021-01-16-sampling-distribution.md %}",
         "size": 4, "font": 1},
        {"id": "Statistical Distributions", "url": "{{ site.baseurl }}{% link _posts/2021-03-27-statistical-distributions.md %}",
         "size": 18, "font": 1.3},
        {"id": "Hypothesis Testing", "url": "{{ site.baseurl }}{% link _posts/2021-01-21-hypothesis-testing.md %}",
         "size": 4, "font": 1},
        {"id": "Maximum Likelihood Estimation", "url": "{{ site.baseurl }}{% link _posts/2021-04-24-maximum-likelihood.md %}",
         "size": 4, "font": 1},
        {"id": "Bayesian Inference", "url": "{{ site.baseurl }}{% link _posts/2022-07-15-bayesian-inference.md %}",
         "size": 18, "font": 1.3},
        {"id": "Gaussian Process", "url": "{{ site.baseurl }}{% link _posts/2022-07-23-gaussian-process.md %}",
         "size": 4, "font": 1},
        {"id": "Eigenvectors and Eigenvalues", "url":"{{ site.baseurl }}{% link _posts/2019-11-02-eigenvectors-and-eigenvalues.md %}",
"size":4, "font":1},
        {"id": "Singular Value Decomposition", "url":"{{ site.baseurl }}{% link _posts/2019-11-03-singular-value-decomposition.md %}",
"size":4, "font":1},
        {"id": "QR Decomposition", "url":"{{ site.baseurl }}{% link _posts/2019-11-19-qr-decomposition.md %}",
"size":4, "font":1},
        {"id": "Vector Projection", "url":"{{ site.baseurl }}{% link _posts/2020-03-04-vector-projection.md %}",
"size":4, "font":1},
        {"id": "Simplex Method", "url":"{{ site.baseurl }}{% link _posts/2019-09-07-simplex-method.md %}", "size": 4, "font": 1},
        {"id": "Gradient Descent", "url": "{{ site.baseurl }}{% link _posts/2019-10-15-gradient-descent.md %}", "size": 4, "font": 1},
        {"id": "Newton's Method", "url": "{{ site.baseurl }}{% link _posts/2020-07-05-newton-method.md %}", "size": 4, "font": 1},
        {"id": "Quasi-Newton Methods", "url": "{{ site.baseurl }}{% link _posts/2020-07-29-quasi-newton-methods.md %}", "size": 4, "font": 1},
        {"id": "Line Search", "url": "{{ site.baseurl }}{% link _posts/2020-08-08-line-search.md %}", "size": 4, "font": 1},
        {"id": "Trust Region", "url": "{{ site.baseurl }}{% link _posts/2020-09-07-trust-region.md %}", "size": 4, "font": 1},
        {"id": "Derivatives", "url":"{{ site.baseurl }}{% link _posts/2019-09-14-derivatives.md %}",
"size":18, "font":1.3},
        {"id": "Integrals", "url":"{{ site.baseurl }}{% link _posts/2019-09-24-integrals.md %}",
"size":18, "font":1.3},
        {"id": "Differential Equations", "url":"{{ site.baseurl }}{% link _posts/2019-09-30-differential-equations.md %}",
"size":4, "font":1},
        {"id": "Taylor Series", "url":"{{ site.baseurl }}{% link _posts/2020-05-08-taylor-series.md %}",
"size":4, "font":1},
        {"id": "Text Similarity", "url":"{{ site.baseurl }}{% link _posts/2020-03-03-text-similarity.md %}",
"size":4, "font":1},
        {"id": "Distance Metrics", "url":"{{ site.baseurl }}{% link _posts/2021-07-29-distance-metrics.md %}",
"size":4, "font":1},
        {"id": "Logistic Regression", "url":"{{ site.baseurl }}{% link _posts/2021-07-29-distance-metrics.md %}",
"size":4, "font":1},
        {"id": "Neural Networks", "url": "{{ site.baseurl }}{% link _posts/2022-11-06-neural-networks.md %}", "size": 30, "font": 2},
        
              
    ],
    "links": [
        {"source": "Integrals", "target": "Statistical Distributions", "distance": 220},
        {"source": "Statistical Distributions", "target": "Hypothesis Testing", "distance": 150},
        {"source": "Statistical Distributions", "target": "Sampling Distribution", "distance": 180},
                        
        {"source": "Loss Functions", "target": "Clustering", "distance": 330},
        {"source": "Loss Functions", "target": "Non-Linear Regression", "distance": 300},
        {"source": "Loss Functions", "target": "Linear Regression", "distance": 300},
        {"source": "Loss Functions", "target": "Logistic Regression", "distance": 280},
        {"source": "Loss Functions", "target": "Maximum Likelihood Estimation", "distance": 300},
        {"source": "Loss Functions", "target": "Newton's Method", "distance": 120},
        {"source": "Loss Functions", "target": "Gradient Descent", "distance": 120},
        {"source": "Loss Functions", "target": "Distance Metrics", "distance": 120},
        
        
        {"source": "Linear Regression", "target": "Time Series Modeling", "distance": 320},
        {"source": "Linear Regression", "target": "Non-Linear Regression", "distance": 250},
        {"source": "Non-Linear Regression", "target": "LOESS", "distance": 150},
        {"source": "Non-Linear Regression", "target": "Interpolation", "distance": 150},
        {"source": "Non-Linear Regression", "target": "Gaussian Process", "distance": 150},
        {"source": "Linear Regression", "target": "Logistic Regression", "distance": 280},
        
        {"source": "Maximum Likelihood Estimation", "target": "Bayesian Inference", "distance": 140},
        {"source": "Statistical Distributions", "target": "Bayesian Inference", "distance": 140},
        
        {"source": "Linear Regression", "target": "Correlation", "distance": 150},
        {"source": "Linear Regression", "target": "QR Decomposition", "distance": 140},
        {"source": "Linear Regression", "target": "Singular Value Decomposition", "distance": 140},
                
        {"source": "Linear Transformations", "target": "QR Decomposition", "distance": 180},
        {"source": "Linear Transformations", "target": "Singular Value Decomposition", "distance": 180},
        {"source": "Linear Transformations", "target": "Eigenvectors and Eigenvalues", "distance": 120},
        {"source": "Linear Transformations", "target": "Vector Projection", "distance": 120},
        {"source": "Linear Transformations", "target": "Simplex Method", "distance": 120},
        
        {"source": "QR Decomposition", "target": "Vector Projection", "distance": 100},
        {"source": "Vector Projection", "target": "Text Similarity", "distance": 140},
        {"source": "Singular Value Decomposition", "target": "Eigenvectors and Eigenvalues", "distance": 100},
        {"source": "Singular Value Decomposition", "target": "Correlation", "distance": 160},
                
        {"source": "Integrals", "target": "Derivatives", "distance": 260},
        {"source": "Integrals", "target": "Differential Equations", "distance": 200},
        {"source": "Derivatives", "target": "Differential Equations", "distance": 200},
        {"source": "Integrals", "target": "Bayesian Inference", "distance": 190},
        {"source": "Bayesian Inference", "target": "Gaussian Process", "distance": 160},
        
        {"source": "Derivatives", "target": "Gradient Descent", "distance": 180},
        {"source": "Derivatives", "target": "Taylor Series", "distance": 100},
        {"source": "Taylor Series", "target": "Newton's Method", "distance": 180},
        
        {"source": "Newton's Method", "target": "Quasi-Newton Methods", "distance": 100},
        
        {"source": "Gradient Descent", "target": "Trust Region", "distance": 120},
        {"source": "Gradient Descent", "target": "Line Search", "distance": 120},
        {"source": "Newton's Method", "target": "Trust Region", "distance": 120},
        
        {"source": "Neural Networks", "target": "Loss Functions", "distance": 521}, 
        {"source": "Neural Networks", "target": "Linear Transformations", "distance": 560}
        
    ]   
};

var label = {
    'nodes': [],
    'links': []
};

graph.nodes.forEach(function(d, i) {
    label.nodes.push({node: d});
    label.nodes.push({node: d});
    label.links.push({
        source: i * 2,
        target: i * 2 + 1
    });
});

var labelLayout = d3.forceSimulation(label.nodes)
    .force("charge", d3.forceManyBody().strength(-30))
    .force("link", d3.forceLink(label.links).distance(0).strength(1))
    .on("tick", ticked);

var graphLayout = d3.forceSimulation(graph.nodes)
    .force("charge", d3.forceManyBody().strength(-600))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .force("x", d3.forceX(width / 2).strength(0.03))
    .force("y", d3.forceY(height / 2).strength(0.01))
    .force("link", d3.forceLink(graph.links).id(function(d) {return d.id; }).distance(function(d) {return d.distance; }).strength(1))
    .on("tick", ticked);

var adjlist = [];

graph.links.forEach(function(d) {
    adjlist[d.source.index + "-" + d.target.index] = true;
    adjlist[d.target.index + "-" + d.source.index] = true;
});

var svg = d3.select("div#chartId")
    .append("div")
    .classed("svg-container", true)
    .append("svg")
    .attr("preserveAspectRatio", "xMinYMin meet")
    .attr("viewBox", "0 0 1800 2200")
    .classed("svg-content-responsive", true);
 
var container = svg.append("g");

var link = container.append("g").attr("class", "links")
    .selectAll("line")
    .data(graph.links)
    .enter()
    .append("line")
    .attr("stroke", "#273746")
    .attr("stroke-width", "1.5px");

var radius = d3.scaleSqrt()
    .range([0, 6]);
 
var node = container.append("g").attr("class", "nodes")
    .selectAll("g")
    .data(graph.nodes)
    .enter()
    .append("circle")
    .attr("r", function(d) { return radius(d.size); })
    .attr("fill", "#d4d3da")
    .attr("stroke", "#273746")
    .attr("stroke-width", "1.5px")
    .attr("cursor", "move")
    .on("dblclick", dblclick);

node.call(
    d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended)
);

var labelNode = container.append("g").attr("class", "labelNodes")
    .selectAll("text")
    .data(label.nodes)
    .enter()
    .append("svg:a")
    .attr("href", function(d){ return d.node.url; })
    .attr("target", "_blank")
    .append("text") //visible name
    .text(function(d, i) { return i % 2 == 0 ? "" : d.node.id; })
    .attr("dx", 15)
    .attr("text-anchor", "start")
    .style("fill", "#333")
    .style("font-family", "Arial")
    .style("font-size", function(d){ return d.node.font + 'em'; });
 
function ticked() {

    node.call(updateNode);
    link.call(updateLink);

    labelLayout.alphaTarget(0.3).restart();
    labelNode.each(function(d, i) {
        if(i % 2 == 0) {
            d.x = d.node.x;
            d.y = d.node.y;
        } else {
            var b = this.getBBox();

            var diffX = d.x - d.node.x;
            var diffY = d.y - d.node.y;

            var dist = Math.sqrt(diffX * diffX + diffY * diffY);

            var shiftX = b.width * (diffX - dist) / (dist * 2);
            shiftX = Math.max(-b.width, Math.min(0, shiftX));
            var shiftY = 16;
            this.setAttribute("transform", "translate(" + shiftX + "," + shiftY + ")");
        }
    });
    labelNode.call(updateNode);

}

function fixna(x) {
    if (isFinite(x)) return x;
    return 0;
}

function updateLink(link) {
    link.attr("x1", function(d) { return fixna(d.source.x); })
        .attr("y1", function(d) { return fixna(d.source.y); })
        .attr("x2", function(d) { return fixna(d.target.x); })
        .attr("y2", function(d) { return fixna(d.target.y); });
}

function updateNode(node) {
    node.attr("transform", function(d) {
        return "translate(" + fixna(d.x) + "," + fixna(d.y) + ")";
    });
}

function dragstarted(d) {
    d3.event.sourceEvent.stopPropagation();
    if (!d3.event.active) graphLayout.alphaTarget(0.3).restart();
    d3.select(this).raise().attr("fill", "#ecba4e");
    d.fx = d.x;
    d.fy = d.y;
}

function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
}

function dragended(d) {
    if (!d3.event.active) graphLayout.alphaTarget(0);
    d.fx = d3.event.x;
    d.fy = d3.event.y;
}
 
function dblclick(d) {
    d3.select(this).raise().attr("fill", "#d4d3da");
    d.fx = null;
    d.fy = null;
}

</script>
